### mpi-v1.3
+ Signal and derivative look up tables are controlled by one class: [sq_table.hpp](core/sq_table.hpp)
+ Input data are assumed to be fluctuations and not flux. Added `ConvertFromFluxToDeltaf` to config file to switch behaviors.
+ Using Lee12 mean flux option is removed. A better candidate would be interpolating an input flux file. 
+ Signal matrix interpolation axes are reversed to speed up the integration. This makes previous tables uncompetable.
+ MPI branch has been removed of any OpenMP code.
+ Fiducial cosmology has default parameters:

    A      =    6.621420e-02
    n      =   -2.685349e+00
    alpha  =   -2.232763e-01
    B      =    3.591244e+00
    beta   =   -1.768045e-01
    lambda =    3.598261e+02

+ When `FiducialPowerFile` set in config file, an interpolation function takes over. This file should have the following convention:

    Nk Nz
    z1 k1 P11
    z1 k2 P12
    .  .  .

+ Some functions are turned into `inline`.

### v1.2
+ Turn of redshift evolution by passing `--disable-redshift-evolution` to configure script. When redshift evolution is turned off, every pixel pair in each chunk assumed to be at the median redshift of the chunk, and switched to using top-hat bins. However, scaling with a growth function is still functional if passed. Using `beta=0` in fiducial power is recomended.
+ Detailed power spectrum output has build and configuration specifics in the beginning.
+ Log to both `OutputDir` log files and `stdout/stderr`. Save time statistics to `OutputDir/time_log.txt` in fixed width table.
+ Throw `std::runtime_error(msg)` instead of only message.

### v1.1
+ Prints detailed power spectrum output file.
+ Computes Fisher matrix weighted d (raw power), b (noise estimate) and t (fiducial signal estimate) values storing 3 more gsl_vectors.

v1
=====
+ Set `UseLogarithmicVelocity` in config file to 1 to convert by logarithmic spacing.
+ All redshift binning schemes scales derivative matrices with fiducial growth unless `--disable-redshift-growth` is passed to configure or `-DREDSHIFT_GROWTH_POWER` is not passed to preprocessor.
+ Convergence checks if estimated error is negative. Negative errors are substituted with infinite error *only* in convergence---Fisher matrix is not modified.
+ Load balancing takes how many matrices are needed in triangular bins into account. Some bins are skipped since no pixel pair belongs to them.
+ Specify allocated memory in MB to store additional derivative matrices and fiducial signal matrix if possible. This speeds up calculations.
+ The large number added to covariance matrix is 10000.

Prerequisites
=====
+ [GSL](https://www.gnu.org/software/gsl/) is needed for matrix algebra, integration and interpolation.
+ [Python3](https://www.python.org), [Numpy](http://www.numpy.org) and [Scipy](http://www.numpy.org) are needed for fitting.
+ [MPI](https://www.open-mpi.org) is needed to enable parallel computing.

Even though [GSL](https://www.gnu.org/software/gsl/) has built in CBLAS functions, I recommended using an optimized library such as Intel's [MKL](https://software.intel.com/en-us/mkl), [ATLAS](http://math-atlas.sourceforge.net) or [OpenBLAS](https://www.openblas.net). The compiler flags will depend on the system specifics. Modify Makefile accordingly. To link one of these libraries to gsl_cblas, remove `-lgslcblas` from `LDLIBS`. For ATLAS, add `-lcblas -latlas` to `LDLIBS` in your Makefile. To link OpenBLAS, add `-lopenblas`. Intel has [link line advisor](https://software.intel.com/en-us/articles/intel-mkl-link-line-advisor).

Compile and Install
=====
The simplest version can be installed by `./configure && make && make install`. However, this does not enable MPI or any other CBLAS libraries. 

MPI can be enabled by passing `--enable-openmpi`. 

I added some built-in system types. For example, MacBook build is `./configure x64-macos-clang-openblas --enable-openmpi`, which will enable OpenMPI and use OpenBLAS for matrix operations. Another important one is Intel compiler with MKL. If you have Parallel Studio XE 2018 installed: `./configure --build=x64-linux-icpc-mklxe18 --enable-openmpi`. To see all build types: `./configure --print-builds`.

The executables are installed in `bindir`. This is `/usr/local/bin` by default. You can change it by setting `--bindir=your-path`. Make sure it is in your `$PATH`. Alternatively, you can change `/usr/local` by setting `--prefix` and `--exec_prefix`. Typically for clusters, you want to install binaries to `$HOME/bin`; so simply pass `--prefix=$HOME`.

To absorp high k power, you can enable a wide high k bin by setting `--enable-last-k-bin=[number]`. This number will be the last edge.

You can also change interpolation schemes and redshift binning shape. You can also compile in another directory by setting `--srcdir=[source-path]`. For more options run `./configure --help`.

Overview of Programs
=====
+ **LyaPowerEstimate** iterates over multiple qso spectra and estimates one-dimensional Lya power spectrum in the line-of-sight. It maximizes likelihood using Newton-Raphson method. When compiled with MPI compatibility, it distributes qso chunks to multiple CPUs, then reduces the results.
+ **CreateSQLookUpTable** creates look up tables for signal and derivative matrices used in LyaPowerEstimate. When compiled with MPI compatibility, it computes tables for different resolution on multiple CPUs.

Both programs take one common config file.

+ **lorentzian_fit.py** is an intermediate fitting script.

Config File
=====
Bin edges for k start with linear spacing: `K0 + LinearKBinWidth * n`, where `n=[0, NumberOfLinearBins]`. Then continues with log spacing: `K_Edges[NumberOfLinearBins] * 10^(Log10KBinWidth * n)`. Parameters for k binning are:

    K0 0.

    NumberOfLinearBins    5
    NumberOfLog10Bins     13

    LinearKBinWidth       2E-4
    Log10KBinWidth        0.1

Redshift bins are linearly spaced.

    FirstRedshiftBinCenter    1.9
    RedshiftBinWidth          0.2
    NumberOfRedshiftBins      6

Fiducial Palanque fit function parameters when used.
    
    FiducialAmplitude            0.06
    FiducialSlope               -2.6
    FiducialCurvature           -0.1
    FiducialRedshiftPower        0
    FiducialRedshiftCurvature    0
    FiducialLorentzianLambda     0
    
Lookup tables are generated with the following parameters:

    NumberVPoints     200
    NumberZPoints     200
    PixelWidth        4.0
    VelocityLength    1000.

Turn off fiducial signal matrix by setting this to a positive integer integer.
    
    TurnOffBaseline   0

The maximum number of iterations are

    NumberOfIterations    10

Config file has one file list for qso spectra. This file should start with number of qsos, and then have their relative file paths. The location of the file list, and the directory where those files live:

    FileNameList      ./data/qso_dir/qso_list.txt
    FileInputDir      ./data/qso_dir/

The directory for output files and file name base:

    OutputDir         ./data/qso_results/
    OutputFileBase    lya

List of spectograph resolutions (R) is in `FileNameRList`. This file starts with number of Rs.

    FileNameRList     ./data/qso_dir/specres_list.txt

These lookup tables are saved with the follwoing file name bases to `FileInputDir`:

    SignalLookUpTableBase          signal_lookup
    DerivativeSLookUpTableBase     derivative_lookup

Specify allocated memory in MB to store additional derivative matrices and fiducial signal matrix if possible.

    AllocatedMemoryMB 5.

Specify temporary folder. Smooth power spectrum fitting creates temp files to communicate with [py/lorentzian_fit.py](py/lorentzian_fit.py) script. For clusters, you are typically assigned a scratch space such as `scratch` or `project`.

    TemporaryFolder /tmp

To convert with logarithmic velocity, set this to 1. 0 will use EdS approximation.

    UseLogarithmicVelocity 1
    
It is recommended that flux to fluctuations conversion done independently. However, if you want to input flux and convert using mean flux of each chunk, set this to 1.

    ConvertFromFluxToDeltaf  0

Quasar Spectrum File
====
Quasar spectrum file is in binary format. It starts with a header (see [QSOFile](io/qso_file.hpp)), then has wavelength, fluctuations and noise in double arrays. A Python script is added to help conversion between different formats (see [BinaryQSO](py/binary_qso.py)).
